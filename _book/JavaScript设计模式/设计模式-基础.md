<!--
 * @desc:
 * @Author: 余光
 * @Email: webbj97@163.com
 * @Date: 2020-05-13 16:33:51
 -->
<h1 align=center>设计模式——基础知识</h1>

> 了解设计模式，就是了解它的前世今生

**目录**

* <a href="#1">一、动态类型语言和鸭子类型</a>
* <a href="#2">二、多态</a>
* <a href="#3">三、封装</a>
* <a href="#4">四、原型模式+JavaScript对象系统</a>
* <a href="#5">五、总结</a>


<h2 id="1">一、动态类型语言和鸭子类型</h2>

JavaScript就显然是典型的动态类型语言。

我们要了解一个思想，你是需要一个数组类型的数据结构，还是希望一个数据结构拥有部分数组的方法？

例如，一个对象若有 push 和 pop 方法，并且这些方法提供了正确的实现，它就
可以被当作栈来使用。一个对象如果有 length 属性，也可以依照下标来存取属性（最好还要拥
有 slice 和 splice 等方法），这个对象就可以被当作数组来使用。

`“面向接口编程，而不是面向实现编程”`，在 JavaScript 语言中，“面向接口编程”的
过程跟主流的静态类型语言不一样，因此，在 JavaScript 中实现设计模式的过程与在一些我们熟
悉的语言中实现的过程会大相径庭。

<h2 id="2">二、多态</h2>

`“多态”`————从字面上我们可以理解为复数形态。

在代码层面上，多态的实际含义是：**同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。**
换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。

#### 对象的多态性

```js
var makeSound = function( animal ) {
    if ( animal instanceof Duck ) {
        console.log( '嘎嘎嘎' );
    } else if ( animal instanceof Chicken ) {
        console.log( '咯咯咯' );
    }
};
var Duck = function(){};
var Chicken = function(){};
makeSound( new Duck() ); // 嘎嘎嘎
makeSound( new Chicken() ); // 咯咯咯
```

我们可以通过区分动物的类型来得到不同的消息，但如果类型过多，`makeSound`就会越来越繁琐，所以我们需要提取公共部分。

```js
var makeSound = function(animal){
    animal.sound()
}
var Duck = function(){}
Duck.prototype.sound = function(){
    console.log( '嘎嘎嘎' );
};
var Chicken = function(){}
Chicken.prototype.sound = function(){
    console.log( '咯咯咯' );
};
var Dog = function(){}
Dog.prototype.sound = function(){
    console.log( '汪汪汪' );
};
makeSound( new Duck() ); // 嘎嘎嘎
makeSound( new Chicken() );
makeSound( new Dog() );
```

`makeSound`函数在被抽离出来后，不回因为“动物”的添加而不得不做出改变。


<h2 id="3">三、封装</h2>

封装的目的是将信息隐藏，都是将某某某逻辑封装成一个函数，这里我们也用函数来创建一个相对独立的租用与。

```js
var mayObj = (function(){
    var _name = 'yuguang' // 私有变量
    return {
        getName: function(){
            return _name
        }
    }
})();
```

从设计模式的角度出发，封装在更重要的层面体现为`封装变化`。


<h2 id="5">五、总结</h2>

* JavaScript 这种将函数作为一等对象的语言中，函数本身也是对象，函数用来封装行为并
且能够被四处传递。当我们对一些函数发出“调用”的消息时，这些函数会返回不同的执行结
果，这是“多态性”的一种体现，也是很多设计模式在 JavaScript 中可以用高阶函数来代替实现
的原因。

*


