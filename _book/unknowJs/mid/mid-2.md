<img align=center src="../img/3.png"/>

# 你不知道的JS中篇（二）值
> 数组(array)、字符串(string)和数字(number)是一个程序最基本的组成部分，但在 JavaScript 中，它们可谓让人喜忧掺半。
本篇将介绍 JavaScript 中的几个内置值类型，让读者深入了解和合理运用它们。

本篇的篇幅会很大，相当于从侧面对每一个值再次介绍了一遍，再次设立目录，方便大家进行跳转。

<a href="#1">2.1 数组</a>
<a href="#2">2.2 字符串</a>
<a href="#3">2.3 数字</a>
<a href="#1">2.4 小结</a>

<h2 id="1">2.1数组</h2>

和其他强类型语言不同，在 JavaScript 中，数组可以容纳任何类型的值，可以是字符串、 数字、对象(object)，甚至是其他数组(多维数组就是通过这种方式来实现的):
```js
var a = [ 1, "2", [3] ];
a.length;       // 3
a[0] === 1;     // true
a[2][0] === 3;  // true
 ```
 
**使用 delete 运算符可以将单元从数组中删除，但是请注意，单元删除后，数组的 length 属性并不会发生变化**

数组通过数字进行索引，但有趣的是它们也是对象，所以也可以包含字符串键值和属性 `(但这些并不计算在数组长度内)`
```js
var a = [ ];
a[0] = 1;
a["foobar"] = 2;
a.length;  //1
a["foobar"]; // 2
a.foobar; // 2
```
这里有个问题需要特别注意，如果字符串键值能够被强制类型转换为十进制数字的话，它 就会被当作数字索引来处理。
```js
var a = [ ];
a["13"] = 42;
a.length; // 14
```


<h2 id="2">2.2 字符串</h2>

字符串经常被当成字符数组。字符串的内部实现究竟有没有使用数组并不好说，但
JavaScript 中的字符串和字符数组并不是一回事，最多只是看上去相似而已。 例如下面两个值:
```js
var a = "foo";
var b = ["f","o","o"];
```

字符串和数组的确很相似，它们都是类数组，都有 length 属性以及 indexOf(..)(从 ES5 开始数组支持此方法)和 concat(..) 方法:


JavaScript 中字符串是不可变的，而数组是可变的。并且`a[1]` 在 JavaScript 中并非总是合法语法，在老版本的 IE 中就不被允许(现在可以了)。正确的方法应该是 a.charAt(1)。

字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。而数组的成员函数都是在其原始值上进行操作。
```js
c = a.toUpperCase(); 
a === c; // false
a; // "foo"
c; // "FOO"
```

### 字符串“借用”数组的方法
许多数组函数用来处理字符串很方便。虽然字符串没有这些函数，但可以通过“借用”数 组的非变更方法来处理字符串:
```js
a.join;         // undefined
a.map;          // undefined
var c = Array.prototype.join.call( a, "-" );
var d = Array.prototype.map.call( a, function(v){
	return v.toUpperCase() + ".";
} ).join( "" );
c;              // "f-o-o"
d;              // "F.O.O."
```

但是有一个数组方法字符串无法借用——reverse()，`可变更成员函数`，因为字符串是不可变的：

```js
Array.prototype.reverse.call( a );
```

**那个如果需要反转一个字符串，我们可以变通一下！！！**
```js
var c = a.split("").reverse().join("");
// 将a的值转换为字符数组 
// 将数组中的字符进行倒转 
// 将数组中的字符拼接回字符串 
c; // "oof"
```

这种方法的确简单粗暴，但对简单的字符串却完全适用！！！

### Ps：注意
> 上述方法对于包含复杂字符(Unicode，如星号、多字节字符等)的字符串`并不适用`。
> 
> 如果需要经常以字符数组的方式来处理字符串的话，倒不如直接使用数组。这样就不用在字符串和数组之间来回折腾。可以在需要时使用 join("") 将字符数组转换为字符串。


<h2 id="3">2.3 数字</h2>

JavaScript 只有一种数值类型:number(数字)，包括“整数”和带小数的十进制数。此处 “整数”之所以加引号是因为和其他语言不同，`JavaScript 没有真正意义上的整数`.

与大部分现代编程语言(包括几乎所有的脚本语言)一样，JavaScript 中的数字类型是基 于 IEEE 754 标准来实现的，该标准通常也被称为“浮点数”。JavaScript 使用的是`双精度`格式(即 64 位二进制)。

### 2.3.1 数字的语法

JavaScript 中的数字常量一般用十进制表示。例如:
```js
var a = 42;
var b = 42.3;
```

* 数字前面的 0 可以省略: `var a = 0.42;`
* var b = .42; 小数点后小数部分最后面的 0 也可以省略:`var a = 42.0 => var b = 42.`;
* 
由于数字值可以使用 Number 对象进行封装(参见第 3 章)，因此数字值可以调用 Number.prototype中的方法。
  
例如，`tofixed(..)` 方法可指定小数部分的显示位数: 
```js
var a = 42.59;
a.toFixed( 0 ); // "43"
a.toFixed( 1 ); // "42.6"
a.toFixed( 2 ); // "42.59"
a.toFixed( 3 ); // "42.590"
a.toFixed( 4 ); // "42.5900"
```
请注意，上例中的输出结果实际上是给定`数字的字符串`形式，如果指定的小数部分的显示 位数多于实际位数就用 0 补齐。

 toPrecision(..) 方法用来指定有效数位的显示位数:
```js
var a = 42.59;
a.toPrecision( 1 ); // "4e+1"
a.toPrecision( 2 ); // "43"
a.toPrecision( 3 ); // "42.6"
a.toPrecision( 4 ); // "42.59"
a.toPrecision( 5 ); // "42.590"
a.toPrecision( 6 ); // "42.5900"
```

### 2.3.2 较小的数值
二进制浮点数最大的问题，是会出现如下情况:

`0.1 + 0.2 === 0.3; // false`

简单来说，二进制浮点数中的 0.1 和 0.2 并不是十分精确，它们相加的结果并非刚好等于 0.3，而是一个比较接近的数字 0.30000000000000004，所以条件判断结果为 false。

**那么应该怎样来判断 0.1 + 0.2 和 0.3 是否相等呢? 最**

从 ES6 开始，该值定义在 `Number.EPSILON` 中，我们可以直接拿来用，也可以为 ES6 之前
的版本写 polyfill:
```js
if (!Number.EPSILON) {
	Number.EPSILON = Math.pow(2,-52);
}
```

## 2.4 特殊数值
JavaScript 数据类型中有几个特殊的值需要我们特意去记
### 2.4.1 不是值的值
`undefined` 类型只有一个值，即 `undefined`。
`null` 类型也只有一个值，即 `null`。

undefined 和 null 常被用来表示“空的”值或“不是值”的值。二者之间有一些细微的差 别。例如:
* null 指空值(empty value)
* undefined 指没有值(missing value)

或者:
* undefined 指从未赋值
* null 指曾赋过值，但是目前没有值

null 是一个特殊关键字，不是标识符，我们不能将其当作变量来使用和赋值。然而
undefined 却是一个标识符，可以被当作变量来使用和赋值。

### 2.4.2 undefined

在非严格模式下，我们可以为全局标识符 undefined 赋值(这样的设计实在是欠考虑!):

```js
function foo() {
undefined = 2; // 非常糟糕的做法!
}
foo();
function foo() {
	"use strict";
	undefined = 2; // TypeError!
}
foo();
```

**void 运算符**

undefined 是一个内置标识符(除非被重新定义，见前面的介绍)，它的值为 undefined， 通过 void 运算符即可得到该值。
表达式void ___没有返回值，因此返回结果是undefined。void并不改变表达式的结果， 只是让表达式不返回值:
```js
var a = 42;
console.log( void a, a ); // undefined 42
```
按惯例我们用void 0来获得undefined(这主要源自C语言，当然使用void true或其他 void 表达式也是可以的)。void 0、void 1 和 undefined 之间并没有实质上的区别。

### 2.4.3 特殊的数字
数字类型中有几个特殊的值，下面将详细介绍。

**1. 不是数字的数字**

如果数学运算的操作数不是数字类型(或者无法解析为常规的十进制或十六进制数字)， 就无法返回一个有效的数字，这种情况下返回值为 NaN。

NaN 意指“不是一个数字”(not a number)，这个名字容易引起误会，后面将会提到。将它 理解为`无效数值`,`失败数值`或者`坏数值`可能更准确些。

例如:

```js
var a = 2 / "foo";      // NaN
typeof a === "number";  // true
```
换句话说，“不是数字的数字”仍然是数字类型。这种说法可能有点绕。

NaN 是一个“警戒值”(sentinel value，有特殊用途的常规值)，用于指出数字类型中的错误情况，即`执行数学运算没有成功，这是失败后返回的结果`。

NaN是一个特殊值，它和自身不相等，是唯一一个非自反(自反，reflexive，即x === x不成立)的值。而 NaN != NaN 为 true，很奇怪吧?


## 2.4 小结
JavaScript 中的数组是通过数字索引的一组任意类型的值。字符串和数组类似，但是它们的行为特征不同，在将字符作为数组来处理时需要特别小心。JavaScript 中的数字包括“整 数”和“浮点型”。

基本类型中定义了几个特殊的值。

* null 类型只有一个值 null
* undefined 类型也只有一个值 undefined。
* 所有变量在赋值之前默认值都是 undefined。
* void 运算符返回 undefined。


简单标量基本类型值(字符串和数字等)通过值复制来赋值 / 传递，而复合值(对象等) 通过引用复制来赋值 / 传递。
JavaScript 中的引用和其他语言中的引用 / 指针不同，它们不能指向别的变量 / 引用，只能指向值。