<h1 align=center>JavaScript中的基本数据类型和类型检测</h1>

> 在上一篇[JavaScript中的参数传递]()一文中，我们了解到了值传递、引用传递、共享传递，三种传递的第一层区别就在于传入参数的数据类型不同，所以这次，我们来讲讲Js中的基本数据类型。
> Js中的基本数据类型同样是一个老生常谈的问题，通常面试官会将它放在整个面试的前几问，并通过你的回答老决定之后问题的侧重点，比如当你回答基本数据类型时少回答了一个`String`，那么面试官很可能就会问你`String的方法`有哪些了哦～

## 目录：

* <a id="#1">一、类型</a>
* <a id="#2">二、检测（获取）数据类型</a>
* <a id="#3">一、类型</a>


<h2 id="1">一、类型</h2>

可能许多习惯了C++、C#这类静态语言（强类型）语言的小伙伴们在编写Js代码时，会很不习惯，因为相对于静态语言来说，Js甚至没有类型的”概念“。

在Js中，类型是值的内部特征，它定义了值的行为，以使其区别于其他值。

JavaScript中有其中内置类型:

* null
* undefined
* 布尔值（boolean）
* 数字（number）
* 字符串（string）
* 对象（Object）
* symbol（ES6新增）

我们根据他们的存储方式来区分类型

<h2 id="2">二、typeof</h2>

The **typeof** operator returns a string indicating the type of the unevaluated operand —— MDN

如上文所述，它可以检测数据类型，那么我们可以信赖它吗？

用法：

```js
typeof a;
typeof(a);
```

#### 2.1 基本类型大检测

1.检测数字：



```js

```

#### 2.4

1.利用`typeof`检测`null`结果为object，显然我们不能靠次来检测它

```js
typeof null === 'object'; // true

var a = null
if(!a && typeof a === 'object' ) ...Todo
```

2.利用`typeof`检测`function`结果为funtion

typeof



## 1.1.1 动态的属性

定义**基本类型值**和**引用类型值**的方式是类似的:

创建一个变量并为该变量赋值。但是，当这个值保存到变量中以后，对不同类型值可以执行的操作则大相径庭。
- 对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。请看下面的例子:
```js
var person = new Object();
person.name = 'aabbcc';
console.log(person.name);
```
- 对基本类型这样添加属性是无效的（不会报错）。

## 1.1.2 复制变量值

两种类型的值 进行复制操作的过程，也是不同的。

基本类型：

```js
var nameOne = 5;
var nameTwo = 10;
```
<img src="https://raw.githubusercontent.com/webbj97/summary/master/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%93%E9%A2%98/js-Image/2-1.jpg" alt="" width="300px">

`nameOne` 和 `nameTwo` 是两个互不影响的两个值。

引用类型：

```js
var obj1 = new Object;
var obj2 = obj1;
obj1.nge = 100
console.log(obj2); //100
```
<img src="https://raw.githubusercontent.com/webbj97/summary/master/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%93%E9%A2%98/js-Image/2-2.jpg" alt="" width="500px">

此时，obj1类似 Object1的地址，我们将地址复制给了obj2，此时obj1和obj2除了名字不同，其本质都指向了那个对象。

## 1.1.3 传递参数

ECMAScript 中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。

### 基本类型值的传递如同基本类型变量的复制一样
```js
function addTen(num) {
    num += 10;
    return num;
}
var count = 20;
var result = addTen(count);
alert(count); //20，没有变化
alert(result); //30
```

### 引用类型值的传递，则如同引用类型变量的复制一样。
```js
function setName(obj) {
    obj.name = "Nicholas";
}
var person = new Object();
setName(person);
alert(person.name);    //"Nicholas"
```

但这里请大家注意,有很多开发人员（包括我）错误地认为:在局部作用域中修改的对象会在全局作用域中反映出来，
就说明 参数是按引用传递的。为了证明对象是按值传递的，我们再看一看下面这个经过修改的例子:

```js
function setName(obj) {
   obj.name = "Nicholas";
   obj = new Object();
   obj.name = "Greg";
}
var person = new Object();
setName(person);
alert(person.name);    //"Nicholas"
```

这个例子与前一个例子的唯一区别，就是在 setName()函数中添加了两行代码:一行代码为 obj 重新定义了一个对象，另一行代码为该对象定义了一个带有不同值的 name 属性。

在把 person 传递给 setName()后，其 name 属性被设置为"Nicholas"。然后，又将一个新对象赋给变量 obj，同时将其 name 属性设置为"Greg"。

如果 person 是按引用传递的，那么 person 就会自动被修改为指向其 name 属性值 为"Greg"的新对象。但是，当接下来再访问 person.name 时，显示的值仍然是"Nicholas"。

这说明 即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写 obj 时，这 个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。
