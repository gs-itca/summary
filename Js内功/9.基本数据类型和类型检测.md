
<h1 align=center>JavaScript中的基本数据类型和类型检测</h1>

> 在上一篇[JavaScript中的参数传递]()一文中，我们了解到了值传递、引用传递、共享传递，三种传递的第一层区别就在于传入参数的数据类型不同，所以这次，我们来讲讲Js中的基本数据类型。
> 本篇文章是根据《你不知道的Js》第一部分延伸扩展出来的。因为它也是一个老生常谈的问题，通常面试官会将它放在整个面试的前几问，并通过你的回答来决定之后问题的走向，比如当你回答基本数据类型时少回答了一个`String`，那么面试官很可能就会问你`String都有哪方法哦～`

## 目录：

* <a href="#1">一、类型</a>
* <a href="#2">二、typeof类型检测</a>
* <a href="#3">三、值和类型</a>
* <a href="#4">四、基本类型常见问题</a>
* <a href="#5">常见问题</a>

<h2 id="1">一、类型</h2>

可能许多习惯了C++、C#这类静态语言（强类型）语言的小伙伴们在编写Js代码时，会很不习惯，因为相对于静态语言来说，Js甚至没有类型的”概念“。

在Js中，类型是值的内部特征，它定义了值的行为，以使其区别于其他值。

JavaScript中有其中内置类型:

* null
* undefined
* 布尔值（boolean）
* 数字（number）
* 字符串（string）
* 对象（Object）
* symbol（ES6新增）

我们根据他们的存储方式来区分类型，除了**对象**，其他几个都是**基本类型**，这是因为声明变量时不同的内存分配而决定的：

* 基本类型：存储在栈（stack）中的简单数据段，也就是说，它们的值**直接存储在变量访问的位置**。它可以直接存储，是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – `栈`中。这样存储便于迅速查寻变量的值。

* 引用类型：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。你可以想像成房间内放着你需要的物品，而你手里拿着房间的钥匙。这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，通过记录`钥匙`就可以找到对应存储的数据。是的`存储钥匙地址`的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。

<h2 id="2">二、typeof检测基本数据类型</h2>

为了节省篇幅，我们用思维导图来简单的整理一下typeof的使用场景，下方代码仅为部分特殊场景。

#### 思维导图

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200706185843137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center)
#### 代码示例

**2.1 number**

```js
// Numbers 基本数字和小数
typeof 37 === 'number'; // 整数、小数

// 基本数学API和属性
typeof Math.LN2 === 'number'; // Math的属性
typeof Infinity === 'number'; // 无穷
typeof NaN === 'number'; // 特殊的数字类型，not a number

// 被强转称数字的其他数据类型
typeof Number('str') === 'number'; // Number('str') => NaN => number
```

我们需要注意的是`NaN`和`Number('str')`：

* NaN：NaN 属性是代表非数字值的特殊值。该属性用于指示某个值不是数字。可以把 Number 对象设置为该值，来指示其不是数字值，可以使用`isNaN()`来判断一个值是否是 `NaN` 值。
* Number('str')同样会得到NaN

**2.2 string**

```js
typeof (typeof 1) === 'string'; // typeof always returns a string
typeof String(1) === 'string'; // 强转成字符串
```

**2.3 布尔值**

```js
typeof Boolean(1) === 'boolean'; // 强制类型转换
typeof !!(1) === 'boolean'; // two calls of the ! (logical NOT) operator are equivalent to Boolean()
```

**2.4 Symble**

```js
typeof Symbol() === 'symbol'
typeof Symbol('foo') === 'symbol'
```

**2.5 undefined**

一个没有被赋值的变量的数据类型是`undefined`(如果方法或者是语句中操作的变量没有被赋值，则会返回undefined) —— MDN

```js
typeof undefined === 'undefined';
```

#### 2.6 object

```js
typeof { name: '余光' } === 'object';
```

#### 2.7 null —— 注意

值得我们注意恰恰是这个`null`,typeof 对它的处理返回的是`object`

```js
typeof null === 'object'; // true
```

#### 2.8 function

typeof检测函数返回的也是object，这是因为从规范上看`function`实际上是`object`的一个子类型。

```js
// Functions
typeof function() {} === 'function';
typeof class C {} === 'function';
```

每个值更多的细节书上都有，而且大家也发现了，typeof 并不是全能的，它有许多的破绽，那么如果很有效的确定某个值的类型是什么呢？大家不妨思考一下。


<h2 id="3">三、值和类型<h2>

#### 3.1 JavaScript中的变量是没有类型的

来看下面的例子：

```js
var a = 100; // 严格地说 变量a没有类型，它所保存的 100是数字类型的
typeof a === 'number'; // 其实检测是=>typeof 100
```

`变量a`可以随时持有任何类型的`值`。换个角度来理解就是，JavaScript不做“类型强制”；也就是说，语言引擎不要求变量总是持有与其初始值同类型的值。
















我们讲了那么多的基本类型，也可以
## 1.1.1 动态的属性

定义**基本类型值**和**引用类型值**的方式是类似的:

创建一个变量并为该变量赋值。但是，当这个值保存到变量中以后，对不同类型值可以执行的操作则大相径庭。
- 对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。请看下面的例子:
```js
var person = new Object();
person.name = 'aabbcc';
console.log(person.name);
```
- 对基本类型这样添加属性是无效的（不会报错）。

## 1.1.2 复制变量值

两种类型的值 进行复制操作的过程，也是不同的。

基本类型：

```js
var nameOne = 5;
var nameTwo = 10;
```
<img src="https://raw.githubusercontent.com/webbj97/summary/master/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%93%E9%A2%98/js-Image/2-1.jpg" alt="" width="300px">

`nameOne` 和 `nameTwo` 是两个互不影响的两个值。

引用类型：

```js
var obj1 = new Object;
var obj2 = obj1;
obj1.nge = 100
console.log(obj2); //100
```
<img src="https://raw.githubusercontent.com/webbj97/summary/master/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%93%E9%A2%98/js-Image/2-2.jpg" alt="" width="500px">

此时，obj1类似 Object1的地址，我们将地址复制给了obj2，此时obj1和obj2除了名字不同，其本质都指向了那个对象。

## 1.1.3 传递参数

ECMAScript 中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。

### 基本类型值的传递如同基本类型变量的复制一样
```js
function addTen(num) {
    num += 10;
    return num;
}
var count = 20;
var result = addTen(count);
alert(count); //20，没有变化
alert(result); //30
```

### 引用类型值的传递，则如同引用类型变量的复制一样。
```js
function setName(obj) {
    obj.name = "Nicholas";
}
var person = new Object();
setName(person);
alert(person.name);    //"Nicholas"
```

但这里请大家注意,有很多开发人员（包括我）错误地认为:在局部作用域中修改的对象会在全局作用域中反映出来，
就说明 参数是按引用传递的。为了证明对象是按值传递的，我们再看一看下面这个经过修改的例子:

```js
function setName(obj) {
   obj.name = "Nicholas";
   obj = new Object();
   obj.name = "Greg";
}
var person = new Object();
setName(person);
alert(person.name);    //"Nicholas"
```

这个例子与前一个例子的唯一区别，就是在 setName()函数中添加了两行代码:一行代码为 obj 重新定义了一个对象，另一行代码为该对象定义了一个带有不同值的 name 属性。

在把 person 传递给 setName()后，其 name 属性被设置为"Nicholas"。然后，又将一个新对象赋给变量 obj，同时将其 name 属性设置为"Greg"。

如果 person 是按引用传递的，那么 person 就会自动被修改为指向其 name 属性值 为"Greg"的新对象。但是，当接下来再访问 person.name 时，显示的值仍然是"Nicholas"。

这说明 即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写 obj 时，这 个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。
